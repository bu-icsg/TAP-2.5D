class Node:
	def __init__(self, value = None, left = None, right = None):
		self.left = left
		self.right = right
		self.parent = None
		self.ind = value
		self.x = None
		self.y = None
		self.width = None
		self.height = None

	def set_node_value(self, value, x = None, y = None, width = None, height = None):
		self.ind = value
		self.x = x
		self.y = y
		self.width = width
		self.height = height

class Bstree:
	def __init__(self, root = None):
		self.root = root

	# def insertLeft(self, newnode):
	# 	self.left = Node(newnode)

	# def insertRight(self, newnode):
	# 	self.right = Node(newnode)
	
	def find_node(self, node, ind):
		if node == None:
			return None
		if node.ind == ind:
			return node
		res = self.find_node(node.left, ind)
		if res:
			return res
		return self.find_node(node.right, ind)

	def addnode(self, node, ind, x, y, width, height):
		# adding a new node (provided ind, x, y, width, height) to the left or right child of current node
		if node == None:
			return False
		if self.root.ind == None:
			self.root.set_node_value(ind, x, y, width, height)
			print ('Node ', ind, 'add to the root')
			return True
		elif x == node.x + node.width and y <= node.y + node.height and y + height >= node.y:
			if node.left == None:
				node.left = Node()
				node.left.set_node_value(ind, x, y, width, height)
				node.left.parent = node
				print ('Node ', ind, 'add to the left of ', node.ind)
				return True
		elif x == node.x:
			if node.right == None:
				node.right = Node()
				node.right.set_node_value(ind, x, y, width, height)
				node.right.parent = node
				print ('Node ', ind, 'add to the right of ', node.ind)
				return True
		# print (x, 'is not equal to either', node.x, 'or', node.x+node.width)
		try_right = self.addnode(node.right, ind, x, y, width, height)
		if not try_right:
			return self.addnode(node.left, ind, x, y, width, height)
		else:
			return True

	def flp2bstree(self, ox, oy, owidth, oheight):
		# x, y, width, height describes an admissible floorplan generated by a tight placement (or a naive side-by-side placement)
		# x, y are bottom-left coordinates of chiplet
		x, y, width, height = ox[:], oy[:], owidth[:], oheight[:]
		chiplet_count = len(x)
		ind = [i for i in range(chiplet_count)]
		x, y, width, height, ind = list(map(list, zip(*sorted(zip(x,y,width,height, ind), key=lambda pair: pair[0:2]))))
		print (ind, x, y, width, height)
		self.root = Node()
		# self.root.set_node_value(ind[0], x[0], y[0], width[0], height[0])
		print (self.root)
		for i in range(chiplet_count):
			self.addnode(self.root, ind[i], x[i], y[i], width[i], height[i])
		print ('print tree preorder')
		self.printTree(self.root)
		return self.root

	def resetloc(self, node):
		if node == None:
			return
		node.x, node.y = None, None
		self.resetloc(node.left)
		self.resetloc(node.right)

	def computex(self, node):
		if node == None:
			return
		if node.left:
			node.left.x = node.x + node.width
			self.xpoint.add(node.left.x)
			self.xpoint.add(node.left.x + node.left.width)
			self.computex(node.left)
		if node.right:
			node.right.x = node.x
			self.xpoint.add(node.right.x)
			self.xpoint.add(node.right.x + node.right.width)
			self.computex(node.right)

	def computey(self, node):
		if node == None:
			return
		y = 0
		for i in range(len(self.xpoint)):
			if node.x <= self.xpoint[i] < node.x + node.width:
				y = max(y, self.flp[i])
		node.y = y
		for i in range(len(self.xpoint)):
			if node.x <= self.xpoint[i] < node.x + node.width:
				self.flp[i] = y + node.height
		self.computey(node.left)
		self.computey(node.right)

	def bstree2flp(self):
		# need to recompute the x, y location. since the tree may have rotate/swap/move node
		self.resetloc(self.root)
		self.root.x = 0
		self.root.y = 0
		self.xpoint = set([0])
		self.computex(self.root)
		self.xpoint = sorted(list(self.xpoint))
		self.flp = [0] * len(self.xpoint)
		print (self.xpoint)
		self.computey(self.root)

	def rotate(self, node):
		# rotate do not change B*-tree structure, but will impact the flp
		node.width, node.height = node.height, node.width
		self.bstree2flp()

	def swap(self, node1, node2):
		# instead of applying insert and delete operations, we use an alternative by swapping the index, width and height, but maintain the tree relationship and update the xy coordinates.
		node1.width, node2.width = node2.width, node1.width
		node1.height, node2.height = node2.height, node1.height
		node1.ind, node2.ind = node2.ind, node1.ind
		self.bstree2flp()

	def delete(self, node):
		if node.left and node.right:
			# the node has two children
			snode = node
			while (snode.left and snode.right):
				self.swap(snode, snode.left)
				snode = snode.left
			if snode.left:
				snode.parent.left = snode.left
				snode.left.parent = snode.parent
			elif snode.right:
				snode.parent.left = snode.right
				snode.right.parent = snode.parent
			else:
				snode.parent.left = None
				snode.parent = None
		elif node.left:
			# the node has only left child
			if node.parent.left == node:
				node.parent.left = node.left
			elif node.parent.right == node:
				node.parent.right = node.left
			node.left.parent = node.parent
		elif node.right:
			# the node has only right child
			if node.parent.left == node:
				node.parent.left = node.right
			elif node.parent.right == node:
				node.parent.right = node.right
			node.right.parent = node.parent
		else:
			# the node is a leaf, just delete it
			if node.parent.left == node:
				node.parent.left = None
			elif node.parent.right == node:
				node.parent.right = None
			node.parent = None

	# def insert(self, node):

	# def move(self, node1)???

	def printTree(self, tree):
		if tree == self.root:
			print ('ind', 'x', 'y', 'width', 'height', 'parent','left','right', sep = '\t')
		if tree != None:
			print (tree.ind, tree.x, tree.y, tree.width, tree.height, tree.parent.ind if tree.parent else None, tree.left.ind if tree.left else None, tree.right.ind if tree.right else None, sep='\t')
			self.printTree(tree.left)
			self.printTree(tree.right)

if __name__ == "__main__":
	# example 1
	# x = [0, 2, 2, 0]
	# y = [0, 0, 1, 3]
	# width = [2, 1, 2, 3]
	# height = [2, 1, 2, 1]

	# example 2
	# node   0  1    2  3    4    5  6  7
	x = 	[0, 3, 	 0, 3, 	 5,   2, 0, 3]
	y = 	[0, 0, 	 2, 1.5, 1.5, 3, 5, 4]
	width = [3, 4, 	 2, 2, 	 1,   4, 3, 4]
	height =[2, 1.5, 3, 1.5, 1,   1, 2, 2]

	# example 3
	# x = [0, 0, 1, 1]
	# y = [0, 1, 0, 1]
	# width = [1,1,1,1]
	# height = [1,1,1,1]

	tree = Bstree()
	root = tree.flp2bstree(x, y, width, height)
	tree.resetloc(root)
	print (' ')
	tree.printTree(root)
	tree.bstree2flp()
	print (' ')
	tree.printTree(root)
	# tree.swap(root.left, root.right)
	tree.delete(tree.find_node(root, 0))
	tree.bstree2flp()
	print (' ')
	tree.printTree(root)
	print (tree.root.ind)
